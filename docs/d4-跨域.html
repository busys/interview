<h3>1. 什么是跨域</h3>
<p>跨域是因为浏览器需要遵循同源策略,发出的请求即使能成功,也会被浏览器拦截. 不同源的服务访问会导致跨域.</p>
<h3>2. 同源策略</h3>
<p>域名,协议,端口相同即同源. 浏览器只允许同源的服务之间互相访问.</p>
<h3>3. 为什么有同源策略</h3>
<p>主要避免XSS, CSRF攻击</p>
<ol>
<li>xss - 跨站点脚本攻击 攻击者得脚本注入到系统中,导致系统无法正常使用</li>
</ol>
<ul>
<li>httponly防止截获cookie</li>
<li>用户输入检查</li>
<li>服务端输出检查</li>
</ul>
<ol start="2">
<li>csrf - 跨站点请求伪造 劫持受信任的用户,向服务器发送非预期的请求</li>
</ol>
<ul>
<li>两步验证, 验证码, token</li>
<li>referer检查</li>
</ul>
<h3>4. 跨域的解决方案</h3>
<p>jsonp, cors, 代理, iframe, postMessage</p>
<h3>5. jsonp原理</h3>
<p>预先在script请求之前其他域资源前定义好执行方法,然后将方法名传递给服务端,服务端收到请求后将数据返回,并用方法名包裹,返回之后即会执行预先定义的方法.</p>
<h3>6. 常见的跨域场景</h3>
<p>域名,协议,端口任意一个不同都会跨域. 即使时域名和ip互相也会跨域</p>
<h3>7. postMessage跨域</h3>
<p>window.postMessage可以简单的实现跨域通信
页面脚本执行完成之后,向目标窗口派发MessageEvent消息
postMessage(data, origin) 协议+主机+端口号</p>
<h3>8. 资源共享跨域（CORS）</h3>
<p>服务端返回头中设置 Access-Control-Allow-Origin</p>
<h3>9. nginx代理跨域</h3>
<h3>1. nodejs中间件代理跨域</h3>
<h3>1. webscoket协议跨域</h3>
