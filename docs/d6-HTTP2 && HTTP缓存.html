<h3>1. http/2特性</h3>
<ol>
<li>二进制分帧层</li>
<li>多路复用(请求和响应复用)
基于http2中的二进制分帧层. 客户端和服务端可以将http消息分解成互不依赖的帧,交错发出,然后在另外一侧进行组装</li>
<li>每个来源一个连接</li>
<li>流控制</li>
<li>服务器推送</li>
</ol>
<h3>2. 什么是缓存？又有什么用？</h3>
<p>缓存: 将资源临时保存,下次需要使用时可以直接从保存的地方拿
可以加速获取资源内容
提高网站和应用的性能
缓解服务器的压力,提升性能</p>
<h3>3. 你知道有哪些缓存方式吗？</h3>
<p>浏览器缓存
CDN缓存
代理缓存
网管缓存
反向代理缓存</p>
<h3>4. 缓存位置</h3>
<ol>
<li>service Worker</li>
<li>memory cache</li>
<li>disk cache</li>
</ol>
<h3>5. HTTP2的伪头字段</h3>
<p>伪头部字段是http2内置的几个以:开始的key,用以替代http/1.x中请求行和响应行中的信息,比如请求方法和状态码
:method,:schema,:authority,:path
:status</p>
<h3>6. HTTP 2:服务器推送</h3>
<p>http2新增的一个强大功能就是服务器对客户端的一个请求可以发送多个响应
推送的资源可以进行以下处理</p>
<ol>
<li>由客户端缓存</li>
<li>在不同页面之间复用</li>
<li>与其他资源一起复用</li>
<li>由服务器设定优先级</li>
<li>被客户端拒绝</li>
</ol>
<h3>7. 队首阻塞问题</h3>
<p>http/1.1和http/2都存在队头阻塞问题
http/1.1为http级别的队头阻塞
http/2的虽然有二进制分帧和多路复用,可以解决http的队头阻塞. 但是tcp本身也存在队头阻塞问题,队头阻塞的问题在弱网环境下更严重
QUIC解决队头阻塞: 传输层基于UDP,数据包在接收端没有处理顺序,即使丢失一个包也不会阻塞整条链路的请求. 且QUIC的传输单元是packet, 加密,传输,解密都基于packet.这样能避免TLS的队头阻塞.</p>
<h3>7. Transport头域</h3>
<ul>
<li>connection字段
close: 告诉web服务器,请求完成之后断开连接
keep: 保持连接等待后续的请求</li>
<li>host字段 请求资源的internet主机名和端口号</li>
</ul>
<h3>8. 强制缓存</h3>
<p>cache-control: expire 低版本浏览器
private: 浏览器可缓存 默认值
public: 浏览器和客户端都可缓存
max-age=xxx: 缓存内容将在xxx秒后失效
no-cache: 协商缓存
no-store: 不缓存</p>
<h3>9. 对比缓存，用的是标识</h3>
<p>客户端第一次请求时会将缓存标识放入浏览器的缓存数据库,再次请求时header中会携带缓存标识,服务端校验缓存有效会返回304,使用缓存数据库.</p>
<h3>10. 两种缓存标识</h3>
<p>etag if-none-match
last-modify if-modify-since</p>
<h3>11. Service Worker</h3>
<p>给web app提供了离线缓存的能力,可以精细的控制每个文件的请求
特点:
运行在worker上下文中不能访问DOM
独立于主线城外,不会阻塞页面
设计完全异步
出于安全考虑,必须在https下使用</p>
<h3>12. memory cache</h3>
<p>浏览器内存缓存</p>
<h3>13. disk cache</h3>
<p>浏览器硬盘缓存</p>
<p>至于什么时候存memory或者disk.说法不唯一, 靠谱的观点是大文件大概率存硬盘,内存使用率过高的话优先存硬盘</p>
